float4 ScreenSize=float4(1920,(1/1920),(1920/1080),(1080/1920));

static float FlipSize = ScreenSize.w*ScreenSize.x;
static float2 screenRes = {ScreenSize.x,FlipSize};


float4 Timer;
float FadeFactor = 1;


#define SEEDX			Timer.w	
#define PIX			3.1415926535897932384626433832795


#include "enbseries_mastereffect.ini"

//needful variables users should not change
//#define TILT_SHIFT
#define	AUTO_FOCUS
float	FocalPlaneDepth=0.50;
float	FarBlurDepth=50.00;
float	TiltShiftAngle=30.0;
//#define	NOT_BLURRING_SKY_MODE
#define fFlareHorizontal		1



//#include "effect_config.txt"

//--------------------------------------------------------------------------------------
// Textures
//--------------------------------------------------------------------------------------
texture2D texColor;
texture2D texDepth;
texture2D texNoise;
//--------------------------------------------------------------------------------------
// Sampler Inputs
//--------------------------------------------------------------------------------------


sampler2D InputSampler = sampler_state
{
    Texture = (texColor);
    MinFilter = POINT;
    MagFilter = POINT;
    MipFilter = POINT;
    AddressU   = Clamp;
	AddressV   = Clamp;
	SRGBTexture=FALSE;
	MaxMipLevel=0;
	MipMapLodBias=0;
};

sampler2D SamplerDepth = sampler_state
{
	Texture   = <texDepth>;
	MinFilter = POINT;
	MagFilter = POINT;
	MipFilter = NONE;
	AddressU  = Clamp;
	AddressV  = Clamp;
	SRGBTexture=FALSE;
	MaxMipLevel=0;
	MipMapLodBias=0;
};

sampler2D SamplerNoise = sampler_state
{
	Texture   = <texNoise>;
	MinFilter = POINT;
	MagFilter = POINT;
	MipFilter = NONE;//NONE;
	AddressU  = Wrap;
	AddressV  = Wrap;
	SRGBTexture=FALSE;
	MaxMipLevel=0;
	MipMapLodBias=0;
};

struct VS_OUTPUT_POST
{
	float4 vpos  : POSITION;
	float2 txcoord : TEXCOORD0;
};

struct VS_INPUT_POST
{
	float3 pos  : POSITION;
	float2 txcoord : TEXCOORD0;
};

float pixelWidth;
float pixelHeight;



//--------------------------------------------------------------------------------------
// Vertex Shader Input
//--------------------------------------------------------------------------------------

VS_OUTPUT_POST VS_PostProcess(VS_INPUT_POST IN)
{
 VS_OUTPUT_POST OUT;

 float4 pos=float4(IN.pos.x,IN.pos.y,IN.pos.z,1.0);

 OUT.vpos=pos;
 OUT.txcoord.xy=IN.txcoord.xy;

 return OUT;
}


//--------------------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------------------

#include "effect_functions.txt"




//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------
#if (GPDOF==1)

float4 PS_ProcessPass1(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 res;
	float2 coord=IN.txcoord.xy;

	float4 origcolor=tex2D(InputSampler, coord.xy);
	float scenedepth=tex2D(SamplerDepth, IN.txcoord.xy).x;





	float2 FocusCoords=FocusPoint;

	float2 FocuspixelSize=ScreenSize.y;
	FocuspixelSize.y*=ScreenSize.z;
	
	const float2 Focusoffset[4]=
	{
		float2(0.0, 1.0),
		float2(0.0, -1.0),
		float2(1.0, 0.0),
		float2(-1.0, 0.0)
	};

	float Focusres=linearlizeDepth(tex2D(SamplerDepth, FocusCoords.xy).x);
	for (int i=0; i<4; i++)
	{
		FocusCoords.xy=FocusCoords.xy;
		FocusCoords.xy+=Focusoffset[i] * FocuspixelSize.xy * FocusSampleRange;
		#ifdef NOT_BLURRING_SKY_MODE
			Focusres+=linearlizeDepth(tex2D(SamplerDepth, FocusCoords).x);
		#else
			Focusres+=min(linearlizeDepth(tex2D(SamplerDepth, FocusCoords).x), DepthClip);
		#endif
	}
	Focusres*=0.2;


float scenefocus = Focusres.x;





	//float scenefocus=tex2D(SamplerFocus, 0.5).x;
	res.xyz=origcolor.xyz;

	float depth=linearlizeDepth(scenedepth);


	#ifdef AUTO_FOCUS
		float focalPlaneDepth=scenefocus;
		float farBlurDepth=scenefocus*pow(4.0, FarBlurCurve);
	#else
		float focalPlaneDepth=FocalPlaneDepth;
		float farBlurDepth=FarBlurDepth;
	#endif
	
	#ifdef TILT_SHIFT
		float shiftAngle=(frac(TiltShiftAngle / 90.0) == 0) ? 0.0 : TiltShiftAngle;
		float depthShift=1.0 + (0.5 - coord.x)*tan(-shiftAngle * 0.017453292);
		focalPlaneDepth*=depthShift;
		farBlurDepth*=depthShift;
	#endif
	
	
	if(depth < focalPlaneDepth)
		res.w=(depth - focalPlaneDepth)/focalPlaneDepth;
	else
	{
		res.w=(depth - focalPlaneDepth)/(farBlurDepth - focalPlaneDepth);
		res.w=saturate(res.w);
	}

	res.w=res.w * 0.5 + 0.5;
	
	#ifdef NOT_BLURRING_SKY_MODE
		#define	DEPTH_OF_FIELD_QULITY 0
		res.w=(depth > 1000.0) ? 0.5 : res.w;
	#endif
#if (SPLITSCREEN==1)
	return (IN.txcoord.x < 0.5) ? tex2D(InputSampler, IN.txcoord) : res;
	#endif
	
	return res;
}

float4 PS_ProcessPass2(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 res;
	
	float2 coord=IN.txcoord.xy;

	float4 origcolor=tex2D(InputSampler, coord.xy);
	
	float centerDepth=origcolor.w;

	
	float2 pixelSize=ScreenSize.y;
	pixelSize.y*=ScreenSize.z;
	
	float blurAmount=abs(centerDepth * 2.0 - 1.0);
	float discRadius=blurAmount * float(DEPTH_OF_FIELD_QULITY);
	discRadius*=RadiusSacleMultipiler;
	
	#ifdef AUTO_FOCUS
		discRadius*=(centerDepth < 0.5) ? (1.0 / max(NearBlurCurve, 1.0)) : 1.0;
	#endif
	
	
	res.xyz=origcolor.xyz;
	res.w=dot(res.xyz, 0.3333);
	res.w=max((res.w - BokehBrightnessThreshold) * BokehBrightnessMultipiler, 0.0);
	res.xyz*=1.0 + res.w*blurAmount;
	
	res.w=1.0;
	
	int sampleCycle=0;
	int sampleCycleCounter=0;
	int sampleCounterInCycle=0;
	
	#ifdef POLYGONAL_BOKEH
		float basedAngle=360.0 / POLYGON_NUM;
		float2 currentVertex;
		float2 nextVertex;
	
		int	dofTaps=DEPTH_OF_FIELD_QULITY * (DEPTH_OF_FIELD_QULITY + 1) * POLYGON_NUM / 2.0;
	#else
		int	dofTaps=DEPTH_OF_FIELD_QULITY * (DEPTH_OF_FIELD_QULITY + 1) * 4;
	#endif
		
	
	for(int i=0; i < dofTaps; i++)
	{
		if(sampleCounterInCycle % sampleCycle == 0) 
		{
			sampleCounterInCycle=0;
			sampleCycleCounter++;
		
			#ifdef POLYGONAL_BOKEH
				sampleCycle+=POLYGON_NUM;
				currentVertex.xy=float2(1.0 , 0.0);
				sincos(basedAngle* 0.017453292, nextVertex.y, nextVertex.x);	
			#else	
				sampleCycle+=8;
			#endif
		}
		sampleCounterInCycle++;
		
		#ifdef POLYGONAL_BOKEH
			float sampleAngle=basedAngle / float(sampleCycleCounter) * sampleCounterInCycle;
			float remainAngle=frac(sampleAngle / basedAngle) * basedAngle;
		
			if(remainAngle == 0)
			{
				currentVertex=nextVertex;
				sincos((sampleAngle +  basedAngle) * 0.017453292, nextVertex.y, nextVertex.x);
			}

			float2 sampleOffset=lerp(currentVertex.xy, nextVertex.xy, remainAngle / basedAngle);
		#else
			float sampleAngle=0.78539816 / float(sampleCycleCounter) * sampleCounterInCycle;
			float2 sampleOffset;
			sincos(sampleAngle, sampleOffset.y, sampleOffset.x);
		#endif
		
		sampleOffset*=sampleCycleCounter / float(DEPTH_OF_FIELD_QULITY);
		float2  coordLow=coord.xy + (pixelSize.xy * sampleOffset.xy * discRadius);
		float4 tap=tex2D(InputSampler, coordLow.xy);
		
		float weight=(tap.w >= centerDepth) ? 1.0 : abs(tap.w * 2.0 - 1.0);
		
		float luma=dot(tap.xyz, 0.3333);
		float brightMultipiler=max((luma - BokehBrightnessThreshold) * BokehBrightnessMultipiler, 0.0);
		tap.xyz*=1.0 + brightMultipiler*abs(tap.w*2.0 - 1.0);
		
		tap.xyz*=1.0 + BokehBias * pow(float(sampleCycleCounter)/float(DEPTH_OF_FIELD_QULITY), BokehBiasCurve);
		
	    res.xyz+=tap.xyz * weight;
	    res.w+=weight;
	}

	res.xyz /= res.w;
		
	res.w=centerDepth;



#if (SPLITSCREEN==1)
	return (IN.txcoord.x < 0.5) ? tex2D(InputSampler, IN.txcoord) : res;
	#endif


	return res;
}


float4 PS_ProcessPass3(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{	
	float2 coord=IN.txcoord.xy;
	
	float2 pixelSize=ScreenSize.y;
	pixelSize.y*=ScreenSize.z;
	
	float4 origcolor=tex2D(InputSampler, coord.xy);
	float depth=origcolor.w;
	float blurAmount=abs(depth * 2.0 - 1.0);
	float discRadius=blurAmount * float(DEPTH_OF_FIELD_QULITY) * RadiusSacleMultipiler;
	
	#ifdef AUTO_FOCUS
		discRadius*=(depth < 0.5) ? (1.0 / max(NearBlurCurve, 1.0)) : 1.0;
	#endif
	
	float4 res=origcolor;
	
	float3 distortion=float3(-1.0, 0.0, 1.0);
	distortion*=ChromaticAberrationAmount*discRadius;

	origcolor=tex2D(InputSampler, coord.xy + pixelSize.xy*distortion.x);
	origcolor.w=smoothstep(0.0, depth, origcolor.w);
	res.x=lerp(res.x, origcolor.x, origcolor.w);
	
	origcolor=tex2D(InputSampler, coord.xy + pixelSize.xy*distortion.z);
	origcolor.w=smoothstep(0.0, depth, origcolor.w);
	res.z=lerp(res.z, origcolor.z, origcolor.w);
#if (SPLITSCREEN==1)
	return (IN.txcoord.x < 0.5) ? tex2D(InputSampler, IN.txcoord) : res;
	#endif
	return res;
}

float4 PS_ProcessPass4(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float2 coord=IN.txcoord.xy;
	
	float2 pixelSize=ScreenSize.y;
	pixelSize.y*=ScreenSize.z;
	
	float4 origcolor=tex2D(InputSampler, coord.xy);
	float depth=origcolor.w;
	float blurAmount=abs(depth*2.0 - 1.0);
	
	#if (DEPTH_OF_FIELD_QULITY > 0)
		#ifdef AUTO_FOCUS
			blurAmount*=(depth < 0.5) ? (1.0 / max(NearBlurCurve, 1.0)) : 1.0;
		#endif
		blurAmount=smoothstep(0.15, 1.0, blurAmount);
	#endif
	
	float weight[5] = {0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 
		0.0162162162};
	
	float4 res=origcolor * weight[0];
	
	for(int i=1; i < 5; i++)
	{
		res+=tex2D(InputSampler, coord.xy + float2(i*pixelSize.x*blurAmount, 0)) * weight[i];
		res+=tex2D(InputSampler, coord.xy - float2(i*pixelSize.x*blurAmount, 0)) * weight[i];
	}
	
	
	res.w=depth;
	#if (SPLITSCREEN==1)
	return (IN.txcoord.x < 0.5) ? tex2D(InputSampler, IN.txcoord) : res;
	#endif
	return res;
}

float4 PS_ProcessPass5(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float2 coord=IN.txcoord.xy;
	
	float2 pixelSize=ScreenSize.y;
	pixelSize.y*=ScreenSize.z;
	
	
	float4 origcolor=tex2D(InputSampler, coord.xy);
	float depth=origcolor.w;
	float blurAmount=abs(depth*2.0 - 1.0);
	
	#if (DEPTH_OF_FIELD_QULITY > 0)
		#ifdef AUTO_FOCUS
			blurAmount*=(depth < 0.5) ? (1.0 / max(NearBlurCurve, 1.0)) : 1.0;
		#endif
		blurAmount=smoothstep(0.15, 1.0, blurAmount);
	#endif
	
	float weight[5] = {0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 
		0.0162162162};
	float4 res=origcolor * weight[0];

	for(int i=1; i < 5; i++)
	{
		res+=tex2D(InputSampler, coord.xy + float2(0, i*pixelSize.y*blurAmount)) * weight[i];
		res+=tex2D(InputSampler, coord.xy - float2(0, i*pixelSize.y*blurAmount)) * weight[i];
	}
	
	
	float origgray=dot(res.xyz, 0.3333);
	origgray/=origgray + 1.0;
	coord.xy=IN.txcoord.xy*16.0 + origgray;
	float4 cnoi=tex2D(SamplerNoise, coord);
	float noiseAmount=NoiseAmount*pow(blurAmount, NoiseCurve);
	res=lerp(res, (cnoi.x+0.5)*res, noiseAmount*saturate(1.0-origgray*1.8));
	
	res.w=depth;
	
	#if (SPLITSCREEN==1)
	return (IN.txcoord.x < 0.5) ? tex2D(InputSampler, IN.txcoord) : res;
	#endif
	return res;
}
#endif



float4 Tonemap(VS_OUTPUT_POST i, float2 vPos : VPOS) : COLOR
{


float2 fvTexelSizeBloom = float2(1.0 / 1920, 1.0 / 1080);

#if (SHARPEN==1)
float4 color = 9 * tex2D(InputSampler, i.txcoord);
color -= tex2D(InputSampler, i.txcoord.xy + float2(-fvTexelSizeBloom.x, fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(0.0, fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(fvTexelSizeBloom.x, fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(fvTexelSizeBloom.x, 0.0) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(fvTexelSizeBloom.x, -fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(0.0, -fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(-fvTexelSizeBloom.x, -fvTexelSizeBloom.y) * fSharpScale);
color -= tex2D(InputSampler, i.txcoord.xy + float2(-fvTexelSizeBloom.x, 0.0) * fSharpScale);
#endif

#if (SHARPEN==0)
float4 color = tex2D(InputSampler, i.txcoord);
#endif



#if(BLOOM_CRISP==1)
float steps = EBloomSteps;

float4 bloomcolor= 0;
fvTexelSizeBloom *= EBloomRadius;	
float2 direction;
 
for(float x = 1; x<=steps; x++)
{
	
direction=float2(-0.707, 0.707) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.383, 0.924) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.0, 1.0) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.383, 0.924) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.707, 0.707) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.924, 0.383) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.707, 0.707) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.0, 1.0) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.707, 0.707) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.924, 0.383) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-1.0, 0.0) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-1.0, 0.0) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.0, 0.0)*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(1.0, 0.0) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(1.0, 0.0) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.924, -0.383) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.707, -0.707) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.0, -1.0) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.707, -0.707) * 0.524*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.924, -0.383) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.707, -0.707) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(-0.383, -0.924) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.0, -1.0) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.383, -0.924) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
direction=float2(0.707, -0.707) * 1.282*x*fvTexelSizeBloom;
bloomcolor += tex2Dlod(InputSampler, float4(i.txcoord.xy + direction.xy,0,1)) * (steps-x)*(1/steps);
}
bloomcolor /= 25*steps;

bloomcolor *= bloomcolor*EBloomCurve;

float sVal = EBloomSat;
float sLuma = dot(bloomcolor.xyz,float3(0.27, 0.67, 0.06));
float3 sNcolor = normalize(bloomcolor);
sNcolor.xyz = pow(sNcolor.xyz, sVal);
float sNluma = dot(sNcolor.xyz,float3(0.27, 0.67, 0.06));
bloomcolor.xyz = sNcolor.xyz*sLuma/sNluma;




color += bloomcolor*EBloomAmount;

#endif

	 
#if (SKYRIMTONEMAP==1)

float4	Adaptation=float4( 0.0, 0.0, 0.0, 1 );
float	grayadaptation = Luminance(color);

#if (POSTPROCESS==1)

	grayadaptation = max(grayadaptation, 0.0);
	grayadaptation = min(grayadaptation, 50.0);
	color.xyz =  color.xyz / (grayadaptation * EAdaptationMaxV1 + EAdaptationMinV1);
		
	float cgray = dot( color.xyz, float3(0.27, 0.67, 0.06));
	cgray = pow(cgray, EContrastV1);
	float3 poweredcolor = pow( color.xyz, EColorSaturationV1);
	float newgray = dot(poweredcolor.xyz, float3(0.27, 0.67, 0.06));
	 color.xyz = poweredcolor.xyz * cgray / (newgray + 0.0001);

	float3	luma =  color.xyz;
	float	lumamax = 300.0;
	 color.xyz = ( color.xyz * (1.0 +  color.xyz / lumamax)) / ( color.xyz + EToneMappingCurveV1);	
#endif


#if (POSTPROCESS==2)

	grayadaptation = max(grayadaptation, 0.0);
	grayadaptation = min(grayadaptation, 50.0);
	 color.xyz =  color.xyz / (grayadaptation * EAdaptationMaxV2 + EAdaptationMinV2);
	float3 xncol = normalize( color.xyz);
	float3 scl =  color.xyz / xncol.xyz;
	scl = pow(scl, EIntensityContrastV2);
	xncol.xyz = pow(xncol.xyz, EColorSaturationV2);
	 color.xyz = scl*xncol.xyz;
	float	lumamax = EToneMappingOversaturationV2;
	 color.xyz = ( color.xyz * (1.0 +  color.xyz / lumamax)) / ( color.xyz + EToneMappingCurveV2);
 color.xyz*=4;

#endif


#if (POSTPROCESS==3)
	 color.xyz *= 35;
	float	lumamax = EToneMappingOversaturationV3;
	 color.xyz = ( color.xyz * (1.0 +  color.xyz / lumamax)) / ( color.xyz + EToneMappingCurveV3);
#endif


#if (POSTPROCESS == 4)
	grayadaptation = max(grayadaptation, 0.0);
	grayadaptation = min(grayadaptation, 50.0);
	 color.xyz =  color.xyz / (grayadaptation * EAdaptationMaxV4 + EAdaptationMinV4);

	float Y = dot( color.xyz, float3(0.299, 0.587, 0.114)); //0.299 * R + 0.587 * G + 0.114 * B;
	float U = dot( color.xyz, float3(-0.14713, -0.28886, 0.436)); //-0.14713 * R - 0.28886 * G + 0.436 * B;
	float V = dot( color.xyz, float3(0.615, -0.51499, -0.10001)); //0.615 * R - 0.51499 * G - 0.10001 * B;
		
	Y = pow(Y, EBrightnessCurveV4);
	Y = Y * EBrightnessMultiplierV4;
	 color.xyz = V * float3(1.13983, -0.58060, 0.0) + U * float3(0.0, -0.39465, 2.03211) + Y;
	 color.xyz = max( color.xyz, 0.0);
	 color.xyz =  color.xyz / ( color.xyz + EBrightnessToneMappingCurveV4);
#endif


#if (POSTPROCESS == 5)
	float hnd = 1;
	float2 hndtweak = float2( 3.1 , 1.5 );
	grayadaptation = max(grayadaptation, 0.0);
	grayadaptation = min(grayadaptation, 50.0);
	 color.xyz *= lerp( hndtweak.x, hndtweak.y, hnd );
	float3 xncol = normalize( color.xyz);
	float3 scl =  color.xyz/xncol.xyz;
	scl = pow(scl, EIntensityContrastV5);
	xncol.xyz = pow(xncol.xyz, EColorSaturationV5);
	 color.xyz = scl*xncol.xyz;
	 color.xyz *= HCompensateSatV5; // compensate for darkening caused my EcolorSat above
	 color.xyz =  color.xyz / ( color.xyz + EToneMappingCurveV5);
	 color.xyz *= 4;
#endif

#if (POSTPROCESS==6)
//Postprocessing V6 by Kermles
		//hd6/ppv2///////////////////////////////////////////
		float 	EIntensityContrastV6 = EIntensityContrastV6Day;
		float 	EColorSaturationV6 = EColorSaturationV6Day;
		float 	HCompensateSatV6 = HCompensateSatV6Day;
		float 	EToneMappingCurveV6 = EToneMappingCurveV6Day;
		float 	EBrightnessV6 = EBrightnessV6Day;
		float 	EToneMappingOversaturationV6 = EToneMappingOversaturationV6Day;
		float 	EAdaptationMaxV6 = EAdaptationMaxV6Day;
		float 	EAdaptationMinV6 = EAdaptationMinV6Day;
		float	lumamax = EToneMappingOversaturationV6;
		//kermles////////////////////////////////////////////
		float4 	ncolor;					//temporary variable for color adjustments		
	//begin pp code/////////////////////////////////////////////////
		//ppv2 modified by kermles//////////////////////////////////////
		
		grayadaptation = clamp(grayadaptation, 0, 50);
		 color.xyz *= EBrightnessV6;
		float3 xncol = normalize( color.xyz);
		float3 scl =  color.xyz/xncol.xyz;
		scl = pow(scl, EIntensityContrastV6);
		xncol.xyz = pow(xncol.xyz, EColorSaturationV6);
		 color.xyz = scl*xncol.xyz;
		 color.xyz *= HCompensateSatV6;
		 color.xyz = ( color.xyz * (1.0 +  color.xyz/lumamax))/( color.xyz + EToneMappingCurveV6);
		 color.xyz /= grayadaptation*EAdaptationMaxV6+EAdaptationMinV6;
		//rerun ppv2////////////////////////////////////////////////////
		 color.xyz *= EBrightnessV6;
		xncol = normalize( color.xyz);
		scl =  color.xyz/xncol.xyz;
		scl = pow(scl, EIntensityContrastV6);
		xncol.xyz = pow(xncol.xyz, EColorSaturationV6);
		 color.xyz = scl*xncol.xyz;
		 color.xyz *= HCompensateSatV6;
		 color.xyz = ( color.xyz * (1.0 +  color.xyz/lumamax))/( color.xyz + EToneMappingCurveV6);

#endif
#endif

#define const_1 (DARK_LEVEL/255.0)
#define const_2 (255.0/(255.0-BRIGHT_LEVEL))

#if (TVLEVELS==1)
color.xyz = (color.xyz  - const_1) * const_2;
#endif

#if (COLORWASHOUT==1)
float	colorGray=dot(color.xyz, 0.333);
float	colorGray2=(colorGray*(6.2*colorGray+0.5))/(colorGray*(6.2*colorGray+1.7)+0.06);
float	colorGray3=pow(colorGray, 0.36);
float	colorWashout=saturate(colorGray2 - ColorWashoutThreshold)/(1.00 - ColorWashoutThreshold);
colorWashout=saturate(pow(colorWashout, ColorWashoutPow) * ColorWashoutAmount);

float3	middleColor=(color.xyz+0.0001)/(colorGray+0.000001);
middleColor.xyz=lerp(pow(middleColor.xyz, ColorSaturation), middleColor.xyz, ColorSaturation);
middleColor.xyz=lerp(middleColor.xyz, 1.00, saturate(colorWashout*ColorWashoutAmount));
float tonemapMix=(0.5 - ColorDullnessAmount)*0.60; //temp
	colorGray=lerp(colorGray2, colorGray3, tonemapMix);
	color.xyz=middleColor.xyz*colorGray;
color.xyz *= ExpAdjustment;
#endif

#if (VIBRANCEPASS==1)
float3 lumCoeff = float3(0.2126, 0.7152, 0.0722);
float vibranceluma = dot(lumCoeff, color.xyz);

float max_color = max(color.x, max(color.y,color.z)); //Find the strongest color
float min_color = min(color.x, max(color.y,color.z)); //Find the weakest color
float color_saturation = max_color - min_color;

color.xyz = lerp(vibranceluma, color.xyz, (1.0 + (Vibrance * (1.0 - (sign(Vibrance) * color_saturation)))));
#endif

#if (HDR==1)
color = TonemapPass(color);
#endif

#if (FILMICPASS==1)
color = FilmPass(color);
#endif

#if (CROSSPROCESS==1)
color = CrossProcess_PS(color);
#endif

#if (COLORMOOD==1)
color = MoodPass(color);
#endif

#if (SEPIA==1)
color = SepiaPass(color);
#endif

#if(COLORBOOST==1)
float Zmiddlegray=(color.r+color.g+color.b)*0.333;
float3 Zdiffcolor=color.rgb-Zmiddlegray;
color.rgb+=Zdiffcolor*0.6;
color.rgb-=Zdiffcolor*0.1;
#endif

#if (FINALADJUSTER==1)
color = FinalAdjusterPass(color);
#endif


#if (SPLITSCREEN==1)
	return (i.txcoord.x < 0.5) ? tex2D(InputSampler, i.txcoord) : color;
	#endif

color.w=1;

    return color; 
}




float4 Flares(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{

float4	res;

#if (CHROMATICABBERATION==0)
   float3	origcolor=tex2D(InputSampler, IN.txcoord.xy);
#endif

#if (CHROMATICABBERATION==1)
float4 coord=0.0;
coord.xy=IN.txcoord.xy;
coord.w=0.0;  
float3 eta = float3(1.0+ChromaticAmount*0.9,1.0+ChromaticAmount*0.6,1.0+ChromaticAmount*0.3);
float2 center;
center.x = coord.x-0.5;
center.y = coord.y-0.5;
float LensZoom = 1.0/LensSize;

float r2 = (IN.txcoord.x-0.5) * (IN.txcoord.x-0.5) + (IN.txcoord.y-0.5) * (IN.txcoord.y-0.5);     
float f = 0;

if( LensDistortionCubic == 0.0){
	f = 1 + r2 * LensDistortion;
}else{
                f = 1 + r2 * (LensDistortion + LensDistortionCubic * sqrt(r2));
};

float x = f*LensZoom*(coord.x-0.5)+0.5;
float y = f*LensZoom*(coord.y-0.5)+0.5;
float2 rCoords = (f*eta.r)*LensZoom*(center.xy*0.5)+0.5;
float2 gCoords = (f*eta.g)*LensZoom*(center.xy*0.5)+0.5;
float2 bCoords = (f*eta.b)*LensZoom*(center.xy*0.5)+0.5;

float4 inputDistord = float4(tex2D(InputSampler,rCoords).r , tex2D(InputSampler,gCoords).g ,tex2D(InputSampler,bCoords).b, tex2D(InputSampler,float2(x,y)).a);

float4 schmotzcolor = float4(inputDistord.r,inputDistord.g,inputDistord.b,1);

float3 origcolor = schmotzcolor.xyz;
 
#endif



#if (LENZ==1)
float3	lenz=0;
	float2	lenzuv=0.0;
	
	const float3 offset[15]=
	{
		float3(0.3, 0.01, 4),
		float3(0.7, 0.25, 25),
		float3(0.3, 0.25, 15),
// Full
		float3(1, 1.0, 5),
// Arriere
		float3(-0.15, 20, 1),
		float3(-0.3, 20, 1),
// Avant
		float3(0.5, 0.1, 1),
		float3(0.01, 10, 1),
		float3(20, 0.25, 1),
		float3(1000, 5, 100),
//Plein ecran passe inverse
		float3(0.5, -0.5, 2),
//Rond bleu du debut
		float3(2, 2, -5),
//2eme partie de la passe FS
		float3(-5, 0.2, 0.2),
//Derniere passe
		float3(0.15, 0.5, 20),
		float3(0.4, 1, 10)
	};

const float3 factors[15]=
	{
		float3(0.5, 0.5, 0),
		float3(0, 0.5, 0),
		float3(0, 0, 0.5),
// Full
		float3(0.2, 0.25, 0),
// Arriere
		float3(0.15, 0, 0.0),
		float3(0, 0.0, 0.15),
// Avant
		float3(0.2, 0.2, 0.05),
		float3(0.25, 0.25, 0.25),
		float3(1, 1, 1),
		float3(0, 0.25, 1),
//Plein ecran
		float3(0, 0,0.25),
//Rond bleu au debut
		float3(0, 0, 1),
//Derniere passe avec passe full combine
		float3(2, 2, 2),
		float3(1, 1, 0.25),
		float3(0, 0, 0)

	};


	for (int i=0; i<15; i++)
	{
		float2 distfact=(IN.txcoord.xy-0.5);
		lenzuv.xy=offset[i].x*distfact;
		lenzuv.xy*=pow(2.0*length(float2(distfact.x*ScreenSize.z,distfact.y)), offset[i].y);
		lenzuv.xy*=offset[i].z*0.5;
		lenzuv.xy=0.5-lenzuv.xy;
		float3 templenz=sampleblurred(lenzuv.xy);
		templenz=templenz*factors[i];
		distfact=(lenzuv.xy-0.5);
		distfact*=2.0;
		templenz*=saturate(1.0-dot(distfact,distfact));
		float maxlenz=max(templenz.x, max(templenz.y, templenz.z));
		float tempnor=(maxlenz/(1.0+maxlenz));
		tempnor=pow(tempnor, ELenzPower);
		templenz.xyz*=tempnor;
		lenz+=templenz;
	}


	lenz.xyz*=1.25*ELenzIntensity;

	res.xyz=origcolor + lenz;
#endif
#if (LENZ==0)
res.xyz=origcolor.xyz;
#endif


res.w=1.0;
return res;
}


#if (MATSO_FLARE==1)
float4 PS_ProcessPass_Anamorphic(VS_OUTPUT_POST IN, float2 vPos : VPOS, uniform int axis) : COLOR
{
	float4 res;
	float2 coord = IN.txcoord.xy;
	

#if (fFlareHorizontal==1)
	#define fFlareAxis	0
#endif
#if (fFlareVertical==1)
	#define fFlareAxis	90
#endif
        
	float3 anamFlare = AnamorphicSample(axis, coord.xy, fFlareBlur) * fFlareTint;
#ifdef fFlareHorizontal
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, 4)*FlareRadius, fFlareBlur) * fFlareTint* 0.30;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, 3)*FlareRadius, fFlareBlur) * fFlareTint* 0.54;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, 2)*FlareRadius, fFlareBlur) * fFlareTint* 0.72;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, 1)*FlareRadius, fFlareBlur) * fFlareTint* 0.90;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, -1)*FlareRadius, fFlareBlur) * fFlareTint* 0.90;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, -2)*FlareRadius, fFlareBlur) * fFlareTint* 0.72;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, -3)*FlareRadius, fFlareBlur) * fFlareTint* 0.54;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(0, -4)*FlareRadius, fFlareBlur) * fFlareTint* 0.30;
#endif
#ifdef fFlareVertical
        anamFlare += AnamorphicSample(axis, coord.xy+float2(4, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.30;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(3, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.54;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(2, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.72;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(1, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.90;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(1, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.90;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(2, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.72;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(3, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.54;
	anamFlare += AnamorphicSample(axis, coord.xy+float2(4, 0)*FlareRadius, fFlareBlur) * fFlareTint* 0.30;
#endif

	res.rgb = anamFlare * fFlareIntensity;


	res.a = 1.0;
	return res;
}
#endif


#if (GODRAYS==1)
float4 PS_ProcessSunShafts(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR 
{	
	float2 texCoord = IN.txcoord;
	// Calculate vector from pixel to light source in screen space.  
    half2 deltaTexCoord = (texCoord - ScreenLightPos.xy);  
    // Divide by number of samples and scale by control factor.  
    deltaTexCoord *= 1.0f / NUM_SAMPLES * Density;  
    // Store initial sample.  
    half3 color = max(float4(0,0,0,0),tex2D(InputSampler, texCoord)-SStresh);  
	// Set up illumination decay factor.  
	half illuminationDecay = 1.0f;  
	// Evaluate summation from Equation 3 NUM_SAMPLES iterations.  
	for (int i = 0; i < NUM_SAMPLES; i++)  
	{  
		// Step sample location along ray.  
		texCoord -= deltaTexCoord;  
		// Retrieve sample at new location.  
	    half3 sample = max(float4(0,0,0,0),tex2D(InputSampler, texCoord)-SStresh);  
		// Apply sample attenuation scale/decay factors.  

#ifdef TINTCOLOR
                sample.r *= REDAMOUNT;
		sample.g *= GREENAMOUNT;
		sample.b *= BLUEAMOUNT;
#endif

#ifdef COLORING
sample = dot(sample, float3(0.3, 0.59, 0.11));
                sample.r *= REDAMOUNT;
		sample.g *= GREENAMOUNT;
		sample.b *= BLUEAMOUNT;
#endif

		sample *= illuminationDecay * Weight;  
		// Accumulate combined color.  
		color += sample;  
		// Update exponential decay factor.  
		illuminationDecay *= Decay;  
	}
	// Output final color with a further scale control factor.  
	return float4( saturate(color*SunExposure) , color.x);
}
#endif




float4 Vignettes(VS_OUTPUT_POST i, float2 vPos : VPOS) : COLOR
{

    float4 color = tex2D(InputSampler, i.txcoord);

#if (BORISVIGNETTE==1)
        float2	uv=(i.txcoord-0.5)*EVignetteRadius;
	float	vignetteold=saturate(dot(uv.xy, uv.xy));
	vignetteold=pow(vignetteold, EVignetteCurve);
	#if (VIGNCOLORING==1)
	float3	EVignetteColor=float3(VIGNREDAMOUNT, VIGNGREENAMOUNT, VIGNBLUEAMOUNT);
	#else
	float3	EVignetteColor=float3(0.0, 0.0, 0.0);
	#endif
	color.xyz=lerp(color.xyz, EVignetteColor, vignetteold*EVignetteAmount);
#endif

#if (HD6_VIGNETTE==1)
float rovigpwr = CircularPower; //for a circular vignette
	float2 sqvigpwr = float2( SquareTop, SquareBottom ); // for the top and bottom of the screen
	float vsatstrength = ColorDistortion; // color distortion
	float vignettepow = ContrastSharpen; // increases the contrast and sharpness
	float vstrengthatnight = VignetteBorder;
 
 	float2 inTex = i.txcoord;
 	float vhnd = 0.5;
 	float4 voriginal = color;
 	float4 vcolor = voriginal;
 	vcolor.xyz=1;
 	inTex -= 0.5; // center
 	inTex.y += 0.01; // offset from the center
 	float vignette = 1.0 - dot( inTex, inTex );
 	vcolor *= pow( vignette, vignettepow );
 
 	float4 rvigtex = vcolor;
 	rvigtex.xyz = pow( vcolor, 1 );
 	rvigtex.xyz = lerp(float3(0.5, 0.5, 0.5), rvigtex.xyz, 2.25); // contrast
 	rvigtex.xyz = lerp(float3(1,1,1),rvigtex.xyz,rovigpwr); // strength of the circular vinetty
 
//darken the top and bottom
 	float4 vigtex = vcolor;
 	vcolor.xyz = float3(1,1,1);

#if (LEFTANDRIGHT==1)
 	float3 topv = min((inTex.x+0.5)*2,1.5) * 2; // top
 	float3 botv = min(((0-inTex.x)+0.5)*2,1.5) * 2; // botton
	topv= lerp(float3(1,1,1), topv, sqvigpwr.x);
 	botv= lerp(float3(1,1,1), botv, sqvigpwr.y);
	vigtex.xyz = (topv)*(botv);
#endif
#if (TOPANDBOTTOM==1)
        float3 topv = min((inTex.y+0.5)*2,1.5) * 2; // top
 	float3 botv = min(((0-inTex.y)+0.5)*2,1.5) * 2; // botton
	topv= lerp(float3(1,1,1), topv, sqvigpwr.x);
 	botv= lerp(float3(1,1,1), botv, sqvigpwr.y);
	vigtex.xyz = (topv)*(botv);
#endif
#if (CORNERDARKEN==1)
	float3 rightv = min((inTex.x+0.5)*2,1.5) * 2;
 	float3 leftv = min(((0-inTex.x)+0.5)*2,1.5) * 2; 
        float3 topv = min((inTex.y+0.5)*2,1.5) * 2; 
 	float3 botv = min(((0-inTex.y)+0.5)*2,1.5) * 2; 
 	rightv= lerp(float3(1,1,1), rightv, sqvigpwr.y);
 	leftv= lerp(float3(1,1,1), leftv, sqvigpwr.x);
        topv= lerp(float3(1,1,1), topv, sqvigpwr.x);
 	botv= lerp(float3(1,1,1), botv, sqvigpwr.y);
 	vigtex.xyz = (topv)*(botv)*(rightv)*(leftv);
#endif
 	
 	
 	//vigtex.xyz = lerp(float3(1,1,1),vigtex.xyz,sqvigpwr); // strength of the top and bottom
 
 // mix the two types of vignettes
 	vigtex.xyz*=rvigtex.xyz;
	vigtex.xyz = lerp(vigtex.xyz,float3(1,1,1),(vhnd-vstrengthatnight*vhnd)); //for a dark screen
 	vigtex.xyz = min(vigtex.xyz,1);
 	vigtex.xyz = max(vigtex.xyz,0);
 	float3 vtintensity = dot(voriginal.xyz, float3(0.2125, 0.7154, 0.0721));
 	color.xyz = lerp(vtintensity, voriginal.xyz, ((((1-(vigtex.xyz*2))+2)-1)*vsatstrength)+1 );
  	color.xyz *= (vigtex.xyz);
#endif



float screenwidth = ScreenSize.x;
float screenheight = FlipSize;


#define BUFFER_RCP_WIDTH (1.0 / screenwidth)
#define BUFFER_RCP_HEIGHT (1.0 / screenheight)

#define px BUFFER_RCP_WIDTH
#define py BUFFER_RCP_HEIGHT
#define pixel float2(px,py)

#if (BORDER==1)
float2 distancefromcenter = abs(i.txcoord.xy - 0.5);
bool2 screen_border = step(0.5 - pixel,distancefromcenter);
color.xyz = (!dot(screen_border, 1.0)) ? color.xyz : 0.0;
#endif



#if (USE_DITHER==1)
float screen_size = ScreenSize.x; 
float dither_size = 2.0;  //move to settings?
float dither_bit  = 8.0;  //move to settings?
float grid_position = frac(dot(i.txcoord,(screen_size / dither_size)) + (0.5 / dither_size)); 
float dither_shift = (0.25) * (1.0 / (pow(2,dither_bit) - 1.0));
float3 dither_shift_RGB = float3(dither_shift, dither_shift, dither_shift);
color.xyz += lerp(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); 
#endif


#if (NOISE==1)
float2 Xcoord = i.txcoord.xy;
color.rgb += tex2D(SamplerNoise, Xcoord.xy * 1024).rgb * Grain(float3(Xcoord.xy, SEEDX));
#endif


#if (SPLITSCREEN==1)
	return (i.txcoord.x < 0.5) ? tex2D(InputSampler, i.txcoord) : color;
#endif


color.w = 1.0;

return  color;

}
//--------------------------------------------------------------------------------------
// Compiler
//--------------------------------------------------------------------------------------
#if (GPDOF==1)
technique PostProcess
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessPass1();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}


technique PostProcess2
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessPass2();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}


technique PostProcess3
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessPass3();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}


technique PostProcess4
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessPass4();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}

technique PostProcess5
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessPass5();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}



technique PostProcess6
{
    pass P0
    {
 VertexShader = compile vs_3_0 VS_PostProcess();
 PixelShader  = compile ps_3_0 Tonemap();


 ZEnable=FALSE;
 CullMode=NONE;
 ALPHATESTENABLE=FALSE;
 SEPARATEALPHABLENDENABLE=FALSE;
 AlphaBlendEnable=FALSE;
 FogEnable=FALSE;
 SRGBWRITEENABLE=FALSE;
 }
}

technique PostProcess7

{
    pass P0
    {
 VertexShader = compile vs_3_0 VS_PostProcess();
 PixelShader  = compile ps_3_0 Flares();

DitherEnable=FALSE;
ZEnable=FALSE;
CullMode=NONE;
ALPHATESTENABLE=FALSE;
SEPARATEALPHABLENDENABLE=FALSE;
AlphaBlendEnable=FALSE;
StencilEnable=FALSE;
FogEnable=FALSE;
SRGBWRITEENABLE=FALSE;
 }



#if (MATSO_FLARE==1)
        pass P1
        {
                AlphaBlendEnable = true;
                SrcBlend = One;
                DestBlend = One;
                               
                PixelShader = compile ps_3_0 PS_ProcessPass_Anamorphic(fFlareAxis);
         }
#endif
#if (GODRAYS==1)
	pass P2
	{
		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessSunShafts();
		AlphaBlendEnable=True;
		SrcBlend = One;
		DestBlend = One;
	}
#endif
}


technique PostProcess8
{	
	pass P0
	{
		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 Vignettes();
	}
}
#endif






#if (GPDOF==0)

technique PostProcess
{
    pass P0
    {
 VertexShader = compile vs_3_0 VS_PostProcess();
 PixelShader  = compile ps_3_0 Tonemap();


 ZEnable=FALSE;
 CullMode=NONE;
 ALPHATESTENABLE=FALSE;
 SEPARATEALPHABLENDENABLE=FALSE;
 AlphaBlendEnable=FALSE;
 FogEnable=FALSE;
 SRGBWRITEENABLE=FALSE;
 }
}

technique PostProcess2

{
    pass P0
    {
 VertexShader = compile vs_3_0 VS_PostProcess();
 PixelShader  = compile ps_3_0 Flares();

DitherEnable=FALSE;
ZEnable=FALSE;
CullMode=NONE;
ALPHATESTENABLE=FALSE;
SEPARATEALPHABLENDENABLE=FALSE;
AlphaBlendEnable=FALSE;
StencilEnable=FALSE;
FogEnable=FALSE;
SRGBWRITEENABLE=FALSE;
 }



#if (MATSO_FLARE==1)
        pass P1
        {
                AlphaBlendEnable = true;
                SrcBlend = One;
                DestBlend = One;
                               
                PixelShader = compile ps_3_0 PS_ProcessPass_Anamorphic(fFlareAxis);
         }
#endif
#if (GODRAYS==1)
	pass P2
	{
		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessSunShafts();
		AlphaBlendEnable=True;
		SrcBlend = One;
		DestBlend = One;
	}
#endif
}


technique PostProcess3
{	
	pass P0
	{
		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 Vignettes();
	}
}
#endif
